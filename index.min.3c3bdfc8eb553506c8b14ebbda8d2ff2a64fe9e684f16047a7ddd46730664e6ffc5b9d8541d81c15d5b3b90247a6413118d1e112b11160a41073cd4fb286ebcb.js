const suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){const t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){let e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"https://telego.pixelbox.dev/docs/",title:"Docs",description:"Documentation of Telego.",content:`Full documentation of Telego
`}).add({id:1,href:"https://telego.pixelbox.dev/docs/introduction/",title:"Introduction",description:"Introduction to Telego.",content:`Introduction to Telego
`}).add({id:2,href:"https://telego.pixelbox.dev/docs/introduction/overview/",title:"Overview",description:"Overview of capabilities and general structure.",content:`What is Telego? # This library was designed to be the one-to-one implementation of Telegram Bot API, with all methods and types represented in Go code. It\u0026rsquo;s also, easy-to-use and understand, because of the same naming and types as described in Telegram API with as small as possible differences. Telego provides almost all comments and descriptions in godoc.
Since using bare methods and types is not so convenient, Telego gives you a lot of helpers, utilities, and even update handlers with predicates.
What can it do? # Basically, anything that Telegram provides for developers of bots and much more with wide configuration capabilities, utilities and helpers. It\u0026rsquo;s even added to the official Telegram code examples page.
Quick Start # ⚡️ For a quick start on your new Telegram bot. Quick Start for fast and easy development.
Tutorial # 🪁 For a more descriptive and full tutorial of Telego. Tutorial for full-features overview.
Short explanation # If you want to quickly create your first bot and don\u0026rsquo;t want to know the full capabilities of Telego, visit Quick Start.
If you want to know more, you can go to Tutorial and read about different parts of Telego and how you can combine them. An in-depth explanation of different \u0026ldquo;levels\u0026rdquo; and concepts that Telego may be informally divided is described in Low Level, Medium Level, and High Level respectfully.
Fill free to build your own abstractions around Telego to fulfill your needs if plain Telego isn\u0026rsquo;t enough for you.
⚠️ Telego is still in an unstable version, so not everything may work as expected. How one-to-one implementation achieved? # Managing this number of abilities that Telegram bots provide is quite hard, so Telego parts that represent API are generated from docs itself. Every method and type with respectful documentation is obtained from documentation and restructured in Go code which we can use. If you are interested in how it actually works and how Telego is really easy to maintain up to date, visit generator implementation here.
`}).add({id:3,href:"https://telego.pixelbox.dev/docs/introduction/quick-start/",title:"Quick Start",description:"Quick start with basics of creation of Telegram Bot.",content:`Where to start? # If you are a complete beginner and/or have no experience with Telegram Bots or don\u0026rsquo;t know where to start, highly suggest first reading Bots: An introduction for developers in order to understand what bots can do. If you have questions about how to create/modify a bot or what is a bot token, that is also described in the introduction for developers.
If you are familiar with bots capabilities, but still don\u0026rsquo;t know how they work, you can read at least some parts of the API reference:
Authorizing your bot Making requests Getting updates Starting with Telego # For a quick start, you can follow these simple steps and at the end you will have a simple \u0026ldquo;echo\u0026rdquo; bot that sends your messages back to you. From that you can go further exploring Telegram bots.
⚠️ Error handling may be missing, but I strongly recommend handling all errors. Get Telego with go get.
go get -u github.com/mymmrac/telego Import Telego packages. More about handlers and utils.
import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/mymmrac/telego\u0026#34; th \u0026#34;github.com/mymmrac/telego/telegohandler\u0026#34; tu \u0026#34;github.com/mymmrac/telego/telegoutil\u0026#34; ) Create a bot instance and specify optional settings. More about configuration options.
botToken := os.Getenv(\u0026#34;TOKEN\u0026#34;) bot, err := telego.NewBot(botToken, telego.WithDefaultDebugLogger()) if err != nil { fmt.Println(err) os.Exit(1) } Please keep in mind that default logger may expose sensitive information, use in development only.
It\u0026rsquo;s not recommended to hardcode tokens, so the environment variable was used. Also, both error and debug logs were enabled.
Get and print bot info. More about methods.
botUser, err := bot.GetMe() if err != nil { fmt.Println(err) os.Exit(1) } fmt.Printf(\u0026#34;Bot user: %+v\\n\u0026#34;, botUser) If everything was properly configured, you should see your bot user printed.
Get updates from Telegram via long polling (not recommend, more here).
updates, _ := bot.UpdatesViaLongPolling(nil) // ... defer bot.StopLongPolling() Create bot handler, register new message handler and start handling updates. More about methods and handlers.
bh, _ := th.NewBotHandler(bot, updates) bh.HandleMessage(func(bot *telego.Bot, message telego.Message) { chatID := tu.ID(message.Chat.ID) _, _ = bot.CopyMessage( tu.CopyMessage(chatID, chatID, message.MessageID), ) }) defer bh.Stop() // ... bh.Start() Now you are done, after starting your bot you will see debug logs of updates that came to the bot and any sent messages to the bot will be sent back to you.
Full Code Example package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/mymmrac/telego\u0026#34; th \u0026#34;github.com/mymmrac/telego/telegohandler\u0026#34; tu \u0026#34;github.com/mymmrac/telego/telegoutil\u0026#34; ) func main() { botToken := os.Getenv(\u0026#34;TOKEN\u0026#34;) bot, err := telego.NewBot(botToken, telego.WithDefaultDebugLogger()) if err != nil { fmt.Println(err) os.Exit(1) } botUser, err := bot.GetMe() if err != nil { fmt.Println(err) os.Exit(1) } fmt.Printf(\u0026#34;Bot user: %+v\\n\u0026#34;, botUser) updates, _ := bot.UpdatesViaLongPolling(nil) bh, _ := th.NewBotHandler(bot, updates) bh.HandleMessage(func(bot *telego.Bot, message telego.Message) { chatID := tu.ID(message.Chat.ID) _, _ = bot.CopyMessage( tu.CopyMessage(chatID, chatID, message.MessageID), ) }) defer bh.Stop() defer bot.StopLongPolling() bh.Start() } Next steps # For more information, keep reading the next sections of docs. In tutorial, the same example will be reviewed more closely with different ways to do things.
Most of the things you will need to know can be found in a Telegram Bot API and/or in these docs, so just keep exploring.
You can also look at some other examples located here.
`}).add({id:4,href:"https://telego.pixelbox.dev/docs/introduction/tutorial/",title:"Tutorial",description:"Descriptive tutorial with all aspects of Telego, good place to start.",content:`Introduction # In this tutorial, you will see different parts of a library used to create a simple \u0026ldquo;echo\u0026rdquo; bot with more in depth explanation and different ways to do the same thing.
You will create bot, set different settings, call Telegram to get bot user, start getting updates with specified parameters, use helper method to get updates, handle updates in simple loop, create new bot handler, use general purpose handlers, use message handler, call Telegram method to send message, use Telego utils to simplify methods usage and use With... methods.
⚠️ Error handling may be missing, but I strongly recommend handling all errors. For more examples, visit examples folder in GitHub repo here.
Setup # Get Telego with go get.
go get -u github.com/mymmrac/telego Import telego and os (for getting bot token from environment variables, hard coding access tokens is highly insecure).
import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/mymmrac/telego\u0026#34; ) Create bot instance # Get bot token and create new bots from it, also handle errors.
botToken := os.Getenv(\u0026#34;TOKEN\u0026#34;) bot, err := telego.NewBot(botToken) if err != nil { fmt.Println(err) os.Exit(1) } For this tutorial, let\u0026rsquo;s enable debug logs by adding bot options. More about configuration.
bot, err := telego.NewBot(botToken, telego.WithDefaultDebugLogger()) Here WithDefaultDebugLogger is an option for default logger with debugMode and printErrors set to true.
Get bot user # Call Telegram API to get bot user ( getMe method) and print its info, also handle error. More about methods.
botUser, err := bot.GetMe() if err != nil { fmt.Println(err) os.Exit(1) } fmt.Printf(\u0026#34;Bot user: %+v\\n\u0026#34;, botUser) Good practice to check bot info before starting the main bot functionality. This works as a kind of healthcheck (see configuration for more).
Getting updates # Telegram provides two ways to get updates: long polling and webhook. In this section we will look at how to get updates using long polling. This method is easies for testing since it does not require you to have a public domain or IP with HTTPS support, more on getting updates via webhook here.
Telegram exposes method for getting updates - getUpdateswhich doesn\u0026rsquo;t have any required parameters, but you still can provide some (like last update\u0026rsquo;s offset or timeout). Single call will return \u0026ldquo;unhandled\u0026rdquo; updates (read more about that on description of offset field).
// Returns []telego.Update updates, err := bot.GetUpdates(\u0026amp;telego.GetUpdatesParams{ Offset: 0 }) This will get you a slice of current updates, but to get new updates you should constantly request them with new offset:
offset := 0 for { updates, err := bot.GetUpdates(\u0026amp;telego.GetUpdatesParams{ Offset: offset, Timeout: 5, }) // Handle error ... offset = updates[len(updates) - 1].UpdateID + 1 } Here we are setting offset to last update ID + 1, to get next one.
Getting updates with helper # Since it is really common to get updates, Telego provides helper for that. It will call GetUpdates method in infinite loop and send all received updates into read only chanel, also it will handle updating offset to proper one and retries in case of failures for you.
// Returns \u0026lt;-chan telego.Update updates, err := bot.UpdatesViaLongPolling(nil) To stop getting updates, you should call stop method:
bot.StopLongPolling() More on getting updates via long polling with helper here.
Processing updates # To process updates, you can simply get them one by one in for loop:
for update := range updates { fmt.Printf(\u0026#34;Update: %+v\\n\u0026#34;, update) // Handle update ... } Bot handlers # For simple bots, this might work perfectly, but with more completed one you will soon realize that it\u0026rsquo;s not very convenient. That\u0026rsquo;s why Telego has Bot Handlers.
import th \u0026#34;github.com/mymmrac/telego/telegohandler\u0026#34; For convenience, we use th as an import alias for telegohandler.
Create bot handler:
// You are still getting updates via chanel bh, err := th.NewBotHandler(bot, updates) // ... // Stop at the end ... bh.Stop() Bot handlers work like HTTP handlers, but instead of paths, they use predicates on updates. It\u0026rsquo;s a general purpose handler for any update that matches predicates:
bh.Handle(func(bot *telego.Bot, update telego.Update) { fmt.Printf(\u0026#34;Update: %+v\\n\u0026#34;, update) // Handle update ... }, th.AnyMessage()) Here th.AnyMessage() is a predicate that will match on any update with message. More on predicates here.
Specific bot handlers # Often you want to handle updates with only messages or callback queries, etc. General purpose handlers are suitable for this, but there is a better way todo so.
You can register handler for specific updates, for example, to handle only messages:
bh.HandleMessage(func(bot *telego.Bot, message telego.Message) { fmt.Printf(\u0026#34;Message: %+v\\n\u0026#34;, message) // Handle message ... }) In this case bh.HandleMessage will match any update with non nil message. More on specific handlers here.
Using Telegram methods # Since now, you should know how to get updates, it\u0026rsquo;s time to use some Telegram methods to make your bot interactive. Let\u0026rsquo;s just send your message back to you, essentially make an echo bot. Telego provides one-to-one representation of all the methods Telegram provides with respectful parameters.
bh.HandleMessage(func(bot *telego.Bot, message telego.Message) { chatID := message.Chat.ID sentMessage, err := bot.SendMessage(\u0026amp;telego.SendMessageParams{ ChatID: telego.ChatID{ID: chatID}, Text: message.Text, }) // ... }) Here we took chat ID of the message that came from the user and sent a message with the same text back to the same chat.
Telegram provides two ways to specify chat ID: as chat ID (int64) or as username (string), so Telego provides specific type for that -telego.ChatID which has ID and Username fields that are mutually exclusive.
Since we are build echo bot, sending only text messages isn\u0026rsquo;t sufficient (if you will send an image, for example, this will not work since our new message only contains text), so we can send a copy of the message:
// Handle updates ... chatID := telego.ChatID{ ID: message.Chat.ID } sentMessageID, err := bot.CopyMessage(\u0026amp;telego.CopyMessageParams{ ChatID: chatID, FromChatID: chatID, MessageID: message.MessageID, }) In this case CopyMessage will send back any message, it does not matter if its text, photo or voice message.
Using Telego utils # Some common methods like sending messages, answering callback queries or other have utility methods that will help you easily call methods with all required parameters set by arguments. To use them, import telegoutil package with alias tu for cleaner code:
import tu \u0026#34;github.com/mymmrac/telego/telegoutil\u0026#34; For creating chat IDs, there are two methods:
chatID := tu.ID(1234567) // Or chatID := tu.Username(\u0026#34;@telegram\u0026#34;) For sending messages, you can use:
_, err := bot.SendMessage(tu.Message(tu.ID(1234567), \u0026#34;Hello Telego!\u0026#34;)) // Or to copy message chatID := tu.ID(message.Chat.ID) _, err := bot.CopyMessage(tu.CopyMessage(chatID, chatID, message.MessageID)) There are many more utils to use, see here.
Using With... methods # Let\u0026rsquo;s try to send inline keyboard using utility methods:
_, err := bot.SendMessage(\u0026amp;telego.SendMessageParams{ ChatID: tu.ID(1234567), Text: \u0026#34;Awesome Keyboard\u0026#34;, ReplyMarkup: tu.InlineKeyboard( tu.InlineKeyboardRow( telego.InlineKeyboardButton{ Text: \u0026#34;Callback\u0026#34;, CallbackData: \u0026#34;data\u0026#34;, }, telego.InlineKeyboardButton{ Text: \u0026#34;URL\u0026#34;, URL: \u0026#34;https://example.com\u0026#34;, }, ), tu.InlineKeyboardRow( telego.InlineKeyboardButton{ Text: \u0026#34;Switch to Inline\u0026#34;, SwitchInlineQueryCurrentChat: \u0026#34;telego\u0026#34;, }, ), ), }) Here telego.InlineKeyboardButton has one required parameter (text) and exactly on of optional parameters should be set, callback data, URL, etc.
As you can see using only Telego utils, you can do everything, but it\u0026rsquo;s still not ideal solution; that\u0026rsquo;s why you can try to use With... methods in combination with utils, they allow you to modify parameters without creating explicit variables or using struct literals:
// ... ReplyMarkup: tu.InlineKeyboard( tu.InlineKeyboardRow( tu.InlineKeyboardButton(\u0026#34;Callback\u0026#34;).WithCallbackData(\u0026#34;data\u0026#34;), tu.InlineKeyboardButton(\u0026#34;URL\u0026#34;).WithURL(\u0026#34;https://example.com\u0026#34;), ), tu.InlineKeyboardRow( tu.InlineKeyboardButton(\u0026#34;Switch to Inline\u0026#34;). WithSwitchInlineQueryCurrentChat(\u0026#34;telego\u0026#34;), ), ), // ... You can also chain With... methods to fill more than one parameter, more on them here.
Conclusions \u0026amp; next steps # This tutorial should give you a general overview of Telego features and what you can do with bots, some links for more investigation and knowledge of what can be used. It is highly recommended to read levels section of the docs to understand how you can utilize Telego features and capabilities and configuration to get the idea what you can modify and change for your needs. Reading about updates via webhook will also be useful for production ready bots.
Explore all other features of Telego and enjoy building your bots.
`}).add({id:5,href:"https://telego.pixelbox.dev/docs/setup/",title:"Setup",description:"Setup and some examples.",content:`Setup and some examples
`}).add({id:6,href:"https://telego.pixelbox.dev/docs/setup/configuration/",title:"Configuration",description:"Configuration that Telego provides when creating bot.",content:`Configuration and default values # Telego does not provide a large set of things that can be configured, but still you can set some low-level things starting from the bot API server and ending with your own API caller.
By design, default values that are used when no options are provided, considered to be a good starting point, but if you want to get most out of Telego it is strongly recommended to check what can be configured and decide for your current project what is the best.
There are three main ways to configure your setup:
Bot options Long polling / Webhook helper options Bot handler options ⚠️ Order of options is important. Some options override the same values as others, so it is important to use only one option from \u0026ldquo;group\u0026rdquo; of options (e.g. all options related to logger will override each other).
Bot options # These are options that can be passed as optional arguments to telego.NewBot after bot token.
Most useful of them are: WithHealthCheck, WithLogger, WithAPIServer, WithEmptyValues.
Full list of Bot options:
WithAPIServer Change bot API server URL (reason why to do so here) Default: https://api.telegram.org WithLogger Create you custom logger that implements telego.Logger Default: Telego has build in default logger Note: Please keep in mind that logger may expose sensitive information, use in development only or configure it not to leak unwanted content WithDefaultLogger Configuration of default logger, enable printing debug information and errors Default: false for debug, true for errors WithDefaultDebugLogger Default logger with enabled debug logs WithExtendedDefaultLogger Same as WithDefaultLogger, but allows you to specify strings.Replacer that will replace any string in logs Default: if used default logger will replace bot token into BOT_TOKEN WithDiscardLogger Disable any logs WithHealthCheck Run getMe method on bot creation for health check. WithWarnings Treat any warnings as errors (e.g. deleting already deleted webhook) WithFastHTTPClient By default, Telego uses valyala/fasthttp and you can specify your own client that will be to make requests Default: \u0026amp;fasthttp.Client{} WithEmptyValues Used in combination with telego.Bot.EmptyValue() to get empty values for string parameters in cases where empty parameter is a valid value Default: no empty value is set, so using telego.Bot.EmptyValue() does nothing When enabled: telego.Bot.EmptyValue() returns TELEGO_EMPTY_VALUE which will be erased from request WithCustomEmptyValues Same as WithEmptyValues, but you can set \u0026ldquo;empty value\u0026rdquo; to any string WithAPICaller In case if you think that valyala/fasthttp doesn\u0026rsquo;t feet you use-case as API \u0026ldquo;caller\u0026rdquo;, then you can provide your own implementation of telegoapi.Caller Default: telegoapi.FasthttpAPICaller WithRequestConstructor You can also provide your own way of \u0026ldquo;constructing\u0026rdquo; requests for both regular (JSON) and multipart (key-value \u0026amp; files) requests Default: telegoapi.DefaultConstructor Long polling options # These are options that can be passed as optional arguments to telego.Bot.UpdatesViaLongPolling after getUpdates parameters.
List of options:
WithLongPollingUpdateInterval Update interval for long polling, ensure that between two calls of telego.Bot.GetUpdates will be at least specified time, but it could be longer Default: 0s Note: Telegram has built in a timeout mechanism, to properly use it, set telego.GetUpdatesParams.Timeout to desired timeout and update interval to 0 (default, recommended way) WithLongPollingRetryTimeout Interval before trying to get updates after an error Default: 8s WithLongPollingBuffer Buffer size of update chan that will be returned Default: 100 If telego.GetUpdatesParams passed into bot.UpdatesViaLongPooling as nil, then default timeout of 8s will be applied, unless explicitly specified using non-nil parameter
Webhook options # These are options that can be passed as optional arguments to telego.Bot.UpdatesViaWebhook after getUpdates parameters.
List of options:
WithWebhookServer FastHTTP server to use for webhook listening Default: \u0026amp;fasthttp.Server{} WithWebhookRouter FastHTTP router to use with webhook (from fasthttp/router) Default: router.New() Note: For webhook to work properly POST route with a path specified in telego.Bot.UpdatesViaWebhook must be unset WithWebhookBuffer Buffer size of update chan that will be returned Default: 100 WithWebhookHealthAPI Basic health API on GET /health path of the router Default: disabled Bot handler options # These are options that can be passed as optional arguments to th.NewBotHandler after bot and updates chan.
List of options:
WithStopTimeout Wait for updates to be processed for specified time Default: 0s (stop immediately) `}).add({id:7,href:"https://telego.pixelbox.dev/docs/setup/graceful-shutdown/",title:"Graceful Shutdown",description:"Graceful shutdown for your bot.",content:`Basic example # It is good practice to have a graceful shutdown for bot in order to complete all running tasks.
Most common way to implement it is to use signal.Notify function. First, import required packages.
import ( \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; ) Initialize signal handling and done chan.
sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) done := make(chan struct{}, 1) Note: List of signals to listen for can be extended to your needs, some info about signals here.
Handle stop signal (e.g. Ctrl+C) and stop any running tasks.
go func () { // Wait for stop signal \u0026lt;-sigs // Stop any tasks here ... // Notify that stop is done done \u0026lt;- struct{}{} }() Wait for the stop process to be completed.
// Wait for done signal \u0026lt;-done // Exit program Full Code Example package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/mymmrac/telego\u0026#34; ) func main() { botToken := os.Getenv(\u0026#34;TOKEN\u0026#34;) bot, err := telego.NewBot(botToken, telego.WithDefaultDebugLogger()) if err != nil { fmt.Println(err) os.Exit(1) } sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) done := make(chan struct{}, 1) updates, _ := bot.UpdatesViaLongPolling(nil) for update := range updates { fmt.Println(\u0026#34;Processing update:\u0026#34;, update.UpdateID) time.Sleep(time.Second * 5) // Simulate long process time fmt.Println(\u0026#34;Done update:\u0026#34;, update.UpdateID) } go func() { \u0026lt;-sigs fmt.Println(\u0026#34;Stopping...\u0026#34;) bot.StopLongPolling() fmt.Println(\u0026#34;Long polling done\u0026#34;) done \u0026lt;- struct{}{} }() \u0026lt;-done fmt.Println(\u0026#34;Done\u0026#34;) } Code with all comments also available on GitHub here.
Long polling example # Basically the same as first example, but we need to start handler in goroutine and also call bh.Stop inside stop handler.
Full Code Example package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/mymmrac/telego\u0026#34; th \u0026#34;github.com/mymmrac/telego/telegohandler\u0026#34; ) func main() { botToken := os.Getenv(\u0026#34;TOKEN\u0026#34;) bot, err := telego.NewBot(botToken, telego.WithDefaultDebugLogger()) if err != nil { fmt.Println(err) os.Exit(1) } sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) done := make(chan struct{}, 1) updates, _ := bot.UpdatesViaLongPolling(nil) bh, _ := th.NewBotHandler(bot, updates, th.WithStopTimeout(time.Second*10)) bh.Handle(func(bot *telego.Bot, update telego.Update) { fmt.Println(\u0026#34;Processing update:\u0026#34;, update.UpdateID) time.Sleep(time.Second * 5) // Simulate long process time fmt.Println(\u0026#34;Done update:\u0026#34;, update.UpdateID) }) go func() { \u0026lt;-sigs fmt.Println(\u0026#34;Stopping...\u0026#34;) bot.StopLongPolling() fmt.Println(\u0026#34;Long polling done\u0026#34;) bh.Stop() fmt.Println(\u0026#34;Bot handler done\u0026#34;) done \u0026lt;- struct{}{} }() go bh.Start() fmt.Println(\u0026#34;Handling updates...\u0026#34;) \u0026lt;-done fmt.Println(\u0026#34;Done\u0026#34;) } Code with all comments also available on GitHub here.
Webhook example # Again, pretty similar to the first and second example, but added start for webhook (no need to use goroutine as it is a non-blocking function) and also stop of webhook before stopping bot handler.
Full Code Example package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/mymmrac/telego\u0026#34; th \u0026#34;github.com/mymmrac/telego/telegohandler\u0026#34; ) func main() { botToken := os.Getenv(\u0026#34;TOKEN\u0026#34;) bot, err := telego.NewBot(botToken, telego.WithDefaultDebugLogger()) if err != nil { fmt.Println(err) os.Exit(1) } sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) done := make(chan struct{}, 1) updates, _ := bot.UpdatesViaWebhook(\u0026#34;/bot\u0026#34; + bot.Token()) bh, _ := th.NewBotHandler(bot, updates, th.WithStopTimeout(time.Second*10)) bh.Handle(func(bot *telego.Bot, update telego.Update) { fmt.Println(\u0026#34;Processing update:\u0026#34;, update.UpdateID) time.Sleep(time.Second * 5) // Simulate long process time fmt.Println(\u0026#34;Done update:\u0026#34;, update.UpdateID) }) go func() { \u0026lt;-sigs fmt.Println(\u0026#34;Stopping...\u0026#34;) _ = bot.StopWebhook() fmt.Println(\u0026#34;Webhook done\u0026#34;) bh.Stop() fmt.Println(\u0026#34;Bot handler done\u0026#34;) done \u0026lt;- struct{}{} }() go bh.Start() fmt.Println(\u0026#34;Handling updates...\u0026#34;) _ = bot.StartListeningForWebhook(\u0026#34;localhost:443\u0026#34;) \u0026lt;-done fmt.Println(\u0026#34;Done\u0026#34;) } Code with all comments also available on GitHub here.
`}).add({id:8,href:"https://telego.pixelbox.dev/docs/levels/",title:"Levels",description:"Different ways of using Telego.",content:`Different ways of using Telego
`}).add({id:9,href:"https://telego.pixelbox.dev/docs/levels/low-level/",title:"Low Level",description:"Low level of interaction with Telegram without any helpers.",content:`Hmm\u0026hellip;
`}).add({id:10,href:"https://telego.pixelbox.dev/docs/levels/medium-level/",title:"Medium Level",description:"Medium level of interaction with Telegram using helpers and some utilities.",content:`Hmm\u0026hellip;
`}).add({id:11,href:"https://telego.pixelbox.dev/docs/levels/high-level/",title:"High Level",description:"High level of interaction with Telegram using all helpers and utilities.",content:`Hmm\u0026hellip;
`}).add({id:12,href:"https://telego.pixelbox.dev/docs/methods/",title:"Methods",description:"All about methods and types used in parameters.",content:`All about methods and types used in parameters
`}).add({id:13,href:"https://telego.pixelbox.dev/docs/methods/methods-basics/",title:"Methods Basics",description:"General idea of how to use Telego to call Telegram Bot methods.",content:`Hmm\u0026hellip;
`}).add({id:14,href:"https://telego.pixelbox.dev/docs/methods/getting-updates/",title:"Getting Updates",description:"Getting updates via long polling or webhook without helpers.",content:`Hmm\u0026hellip;
`}).add({id:15,href:"https://telego.pixelbox.dev/docs/methods/sending-files/",title:"Sending Files",description:"Interpretation of files (photos, documents, etc.) and sending them.",content:`Hmm\u0026hellip;
`}).add({id:16,href:"https://telego.pixelbox.dev/docs/helpers/",title:"Helpers",description:"Helper functions and with like methods.",content:`Helper functions and with like methods
`}).add({id:17,href:"https://telego.pixelbox.dev/docs/helpers/updates-long-polling/",title:"Updates via Long Polling",description:"Getting updates via long polling using helper func.",content:`Hmm\u0026hellip;
Marvin\u0026rsquo;s Marvellous Guide to All Things Webhook
`}).add({id:18,href:"https://telego.pixelbox.dev/docs/helpers/updates-webhook/",title:"Updates via Webhook",description:"Getting updates via webhook using helper func.",content:`Hmm\u0026hellip;
`}).add({id:19,href:"https://telego.pixelbox.dev/docs/helpers/with-like-methods/",title:"With Like Methods",description:"Utility methods of parameters and types.",content:`Hmm\u0026hellip;
`}).add({id:20,href:"https://telego.pixelbox.dev/docs/utilities/",title:"Utilities",description:"Utility methods for parameters, types and more.",content:`Utility methods for parameters, types and more
`}).add({id:21,href:"https://telego.pixelbox.dev/docs/utilities/utilities-basics/",title:"Utilities Basics",description:"Utility methods provided by Telego.",content:`Hmm\u0026hellip;
`}).add({id:22,href:"https://telego.pixelbox.dev/docs/handlers/",title:"Handlers",description:"Bot handlers for processing updates with predicates.",content:`Bot handlers for processing updates with predicates
`}).add({id:23,href:"https://telego.pixelbox.dev/docs/handlers/handlers-basics/",title:"Handlers Basics",description:"Basics of using bot handlers (like net/http but with predicates).",content:`Hmm\u0026hellip;
`}).add({id:24,href:"https://telego.pixelbox.dev/docs/handlers/predicates/",title:"Predicates",description:"Predicates provided by Telego for handlers.",content:`Hmm\u0026hellip;
`}).add({id:25,href:"https://telego.pixelbox.dev/docs/handlers/specific-handlers/",title:"Specific Handlers",description:"Using bot handlers for specific updates.",content:`Hmm\u0026hellip;
`}),search.addEventListener("input",t,!0);function t(){const s=5;let n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount===s)break}}})()